1.2 数据抽象
用java类实现的一组值与对值的操作的一系列方法的集合。

可变和不可变数据类
	不可变：实例变量都是private final，如String
	可变：private，但不一定都是final。


继承和接口
！abstract前缺省时默认是public。 
	继承：一个类只能继承一个类。
		基本类继承基本类：子类中方法可以重写也可以直接使用从父类中继承的方法的实现。
		基本类继承抽象类：抽象类和抽象方法都用abstract修饰符，一个类中有一个或多个抽象方法，则是抽象类。子类中必须实现父类抽象类中的所有抽象方法，非抽象方法可以直接使用。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。成员变量与普通类无差别。

		缺点：1）父类的任何改动都会影响它的所有子类；2）子类代码可以访问所有实例变量，因此它们可能会扭曲父类代码的意图。

	实现：一个类可以实现多个接口。
		基本类实现接口：接口中的所有方法都是抽象方法，但不用abstract修饰，因为这隐式默认的。此外接口中的成员变量只能是静态的、不可改变的，即public static final，这也是隐式默认的。

断言：是一条需要在程序的某处确认为true的布尔表达式。若为false，程序将会终止并报告一条出错信息。

作用域
	参数变量：整个方法
	局部变量：当前代码段进行定义之后的所有语句。
	实例变量：为该类的对象保存了数据类型的值，所以作用域是整个类。
	静态变量：也被称为全局变量，类中所有方法都可以访问，作用于全局。


引用和指针
	指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
	引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
http://blog.csdn.net/listening_music/article/details/6921608	
	  int i = 1;
指针：int *p = &i;
引用：int &x = i;

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用不改变指向。
区别：
	1）引用不可以为空，但指针可以为空。前面也说过了引用是对象的别名，引用为空——对象都不存在，怎么可能有别名！所以定义一个引用的时候，必须初始化。
	2）引用不可以改变指向，对一个对象"至死不渝"；但是指针可以改变指向，而指向其它对象。虽然引用不可以改变指向，但是可以改变初始化对象的内容，如：x永远是i的别名，不会改变，但是i的值可以改变，这会导致x的值随之改变。
	3）引用的大小是所指向的变量的大小，因为引用只是一个别名而已；指针是指针本身的大小，指针的内容是一个地址，int类型一般为4个字节。
	4）最后，引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针）。

const修饰的指针
	常量指针：
	const int *p = int const *p //const在这里修饰的*p，这是一个值，所以p指向的对象是一个常量，不能利用指针对指向的变量进行重新赋值操作。；指针p可以改变。
	指针常量：在定义指针常量时必须初始化！
	int* const p=&i; //const修饰的是指针p，所以p是一个常量,一直指向对象i不能改变；但是值*p却可以改变。

	常量引用：
	const int &p=i; 指向常量的引用，指向的对象是常量，不可改变。不能利用引用对指向的变量进行重新赋值操作。

指针传递和引用传递
	1）指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
	2）引用传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
	3）引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

总结
	★相同点：
	●都是地址的概念；
	指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
	★不同点：
	●指针是一个实体，而引用仅是个别名；
	●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
	●引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有     的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）
	●引用不能为空，指针可以为空；
	●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
	●指针和引用的自增(++)运算意义不一样；
	●引用是类型安全的，而指针不是 (引用比指针多了类型检查

指针的指针----句柄




