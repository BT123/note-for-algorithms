1.3背包、队列、栈

泛型，也叫参数化类型。
	用于指定集合中对象类型。如Stack<Item>,其中Item是一个类型参数，也是一个占位符，可以用String代替Item，指定这是一个存储String对象的Stack。
	在java中创建泛型数组是不允许的，如a = new Item[num];所以需要使用类型转换：a = (Item[]) new Object[num];




自动装箱：原始数据类型转换成封装类型，如int->Integer;
自动拆箱：相反。

迭代：Iterator 
	foreach语句:	
		Stack<String> collection = new Stack<String>();
		...
		for (String s : collection)
		   StdOut.println(s);
	等价于：
		Iterator<String> i = collection.iterator();
		while (i.hasNext()) { 
		   String s = i.next();
		   StdOut.println(s);
		}
 一个可迭代的集合数据类型：	
	 集合类需要import java.util.Iterator;
	 1)集合数据类型必须实现一个iterator()方法并返回一个Iterator对象；
	 	集合数据类需要implements Iterable<Item>,Iterable<Item>接口中包含抽象方法iterator()。
	 	如
	 			public Iterator<Item> iterator()  {
       			 return new ListIterator<Item>(first);  
   				 }

	 2)Iterator类必须包含两个方法：hasNext()（返回一个布尔值）和next()（返回集合中的下一个泛型元素）。  
	 	在实现类中的迭代器时要implements Iterator<Item>，其中有hasNext()和next()两个方法(remove()一般为空)。
	 	 	private class ListIterator<Item> implements Iterator<Item> {
        		private Node<Item> current;

		        public ListIterator(Node<Item> first) {
		            current = first;
		        }

		        public boolean hasNext()  { return current != null;                     }
		        public void remove()      { throw new UnsupportedOperationException();  }

		        public Item next() {
		            if (!hasNext()) throw new NoSuchElementException();
		            Item item = current.item;
		            current = current.next; 
		            return item;
		        }
		    }


背包Bag：不支持从中删除元素的集合数据类型。
	  目的是帮助用例收集元素并迭代遍历所有收集到的元素。（迭代顺序不确定且与用例无关）

队列Queue：先进先出FIFO，有顺序。  如各种排队
	  

栈Stack：有顺序，后进先出LIFO。  如桌子上的文件


1.3.3
链表：是一种递归的数据结构，其中的元素为结点。
	结点node：一个结点包含一个泛型的元素和一个指向另一条链表的引用。
		private static class Node<Item> {
		        private Item item;
		        private Node<Item> next;
		    }

在结构化存储数据集时，链表是数组的一种重要的替代方式。

两种表示对象集合的方式：数组和链表。顺序存储和链式存储。	
	数组：顺序存储。通过索引就可以直接访问任意元素。 在初始化时就需要知道元素的数量。
	链表：链式存储。使用的空间大小和元素数量成正比。 需要通过引用访问任意元素。


