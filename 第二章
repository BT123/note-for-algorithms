第二章 排序
2.1 初级排序算法

2.1.2 选择排序
	算法思想：首先找到数组中最小的那个元素，其次将他和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后在剩下的元素里找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直至将整个数组排序。

	算法的时间效率取决于比较的次数，即数组的长度。
	对于长度为N的数组，选择排序需要N次交换，N^2/2次比较。

	两个特点：
		运行时间与输入无关；
		数据移动是最少的。只有N次交换，与数组大小是线性关系。


插入排序
	算法思想：从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中！从后向前！扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置中；重复步骤2。

	与选择排序一样，当前索引左边的所有元素都是有序的，但是位置不确定，为了给更小的元素腾出空间，还要移动。所以当索引到达数组最右端时，排序完成。

	算法所需的时间取决于输入中元素的初始顺序。
	对于长度为N且主键不重复的数组，插入排序需要N^2/4次比较和N^2/4次交换。

	对于部分有序的数组十分高效，也很适合小规模数组。

	代码：
	public static void insertSort(int[] numbers) {   
    int size = numbers.length, temp, j;   
    for(int i=1; i<size; i++) {   
        temp = numbers[i];   
        for(j = i; j > 0 && temp < numbers[j-1]; j--)   
            numbers[j] = numbers[j-1];   
        numbers[j] = temp;   
    	}   
	}


希尔排序？？？
	基于插入排序的快速的排序算法。
	算法思想：是数组中任意间隔为ｈ的元素都是有序的。这样的数组成为ｈ有序数组。一个ｈ有序数组就是ｈ个互相独立的有序数组编制在一起组成的一个数组。

	索引逐次增长，当前大于前一个，按ｈ为间距取出一个字数组，进行比较、排序然后放回原数组，然后继续下一个索引元素。

	ｈ会逐次递减，至１为止。

	也适用于大型数组。对任意排序的数组表现也很好。

归并排序

快速排序

堆排序

































